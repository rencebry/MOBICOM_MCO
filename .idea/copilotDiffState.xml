<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mobicom/s17/group8/mobicom_mco/home/HomeFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mobicom/s17/group8/mobicom_mco/home/HomeFragment.kt" />
              <option name="originalContent" value="package com.mobicom.s17.group8.mobicom_mco.home&#10;&#10;import android.annotation.SuppressLint&#10;import android.app.AlertDialog&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import androidx.fragment.app.Fragment&#10;import android.util.Log&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.mobicom.s17.group8.mobicom_mco.R&#10;import com.mobicom.s17.group8.mobicom_mco.auth.LandingActivity&#10;import com.mobicom.s17.group8.mobicom_mco.databinding.FragmentHomeBinding&#10;import com.mobicom.s17.group8.mobicom_mco.databinding.ListItemTaskBinding&#10;import com.mobicom.s17.group8.mobicom_mco.database.tasks.Task&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;import com.google.firebase.auth.ktx.auth&#10;import com.google.firebase.ktx.Firebase&#10;import com.bumptech.glide.Glide&#10;import com.google.firebase.firestore.ktx.firestore&#10;import com.mobicom.s17.group8.mobicom_mco.database.AppDatabase&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import androidx.core.net.toUri&#10;import com.mobicom.s17.group8.mobicom_mco.database.user.User&#10;import com.mobicom.s17.group8.mobicom_mco.database.user.UserDao&#10;import android.widget.PopupMenu&#10;import com.bumptech.glide.signature.ObjectKey&#10;import java.io.File&#10;&#10;// --- local adapter since adding tasks are not yet implemented ---&#10;class HomeTaskAdapter(private val tasks: List&lt;Task&gt;) : RecyclerView.Adapter&lt;HomeTaskAdapter.TaskViewHolder&gt;() {&#10;&#10;    inner class TaskViewHolder(val binding: ListItemTaskBinding) : RecyclerView.ViewHolder(binding.root)&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TaskViewHolder {&#10;        val binding = ListItemTaskBinding.inflate(LayoutInflater.from(parent.context), parent, false)&#10;        return TaskViewHolder(binding)&#10;    }&#10;&#10;    @SuppressLint(&quot;SetTextI18n&quot;)&#10;    override fun onBindViewHolder(holder: TaskViewHolder, position: Int) {&#10;        val task = tasks[position]&#10;        holder.binding.apply {&#10;            taskNameTv.text = task.title&#10;            taskInfoTv.text = &quot;task label | ${task.dueDate}&quot; // &quot;${task.label} | ${task.dueDate}&quot;&#10;            taskCheckbox.isChecked = task.isCompleted&#10;            //starredIv.visibility = if (task.isStarred) View.VISIBLE else View.GONE&#10;        }&#10;    }&#10;&#10;    override fun getItemCount() = tasks.size&#10;}&#10;&#10;class HomeFragment : Fragment() {&#10;&#10;    private var _binding: FragmentHomeBinding? = null&#10;    private val binding get() = _binding!!&#10;    private val auth = Firebase.auth&#10;    private val db = Firebase.firestore&#10;    private lateinit var userDao: UserDao&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentHomeBinding.inflate(inflater, container, false)&#10;        userDao = AppDatabase.getDatabase(requireContext()).userDao()&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        loadAndObserveUserProfile()&#10;        setDate()&#10;&#10;        binding.ivSettings.setOnClickListener { view -&gt;&#10;            showSettingsMenu(view) // Pass the settings icon view itself&#10;        }&#10;&#10;//        binding.btnStartStudying.setOnClickListener {&#10;//            findNavController().navigate(R.id.nav_study)&#10;//        }&#10;&#10;        val tasksForToday = getPlaceholderTasks()&#10;        val homeTaskAdapter = HomeTaskAdapter(tasksForToday)&#10;        binding.rvHomeTasks.apply {&#10;            layoutManager = LinearLayoutManager(requireContext())&#10;            adapter = homeTaskAdapter&#10;        }&#10;    }&#10;&#10;    private fun loadAndObserveUserProfile() {&#10;        val currentUser = auth.currentUser&#10;        if (currentUser == null) {&#10;            logoutUser() // Should not happen, but safe to check&#10;            return&#10;        }&#10;&#10;        userDao.getUserById(currentUser.uid).observe(viewLifecycleOwner) { userEntity -&gt;&#10;            if (userEntity != null) {&#10;                binding.tvGreeting.text = getString(R.string.hello_user, userEntity.displayName ?: &quot;User&quot;)&#10;&#10;                binding.profileCard.apply {&#10;                    tvNameValue.text = userEntity.displayName ?: &quot;N/A&quot;&#10;                    tvSchoolValue.text = userEntity.school ?: &quot;N/A&quot;&#10;                    tvCourseValue.text = userEntity.course ?: &quot;N/A&quot;&#10;                    tvYearLevelValue.text = userEntity.yearLevel?.toString() ?: &quot;N/A&quot;&#10;                }&#10;&#10;                // Load the profile picture from the local URI&#10;                if (userEntity.localProfilePictureUri != null) {&#10;                    val imageUri = userEntity.localProfilePictureUri.toUri()&#10;                    val imageFile = imageUri.path?.let { File(it) }&#10;&#10;                    if (imageFile != null &amp;&amp; imageFile.exists()) {&#10;                        Glide.with(this@HomeFragment)&#10;                            .load(imageUri)&#10;                            .signature(ObjectKey(imageFile.lastModified()))&#10;                            .placeholder(R.drawable.ic_add_photo)&#10;                            .error(R.drawable.ic_add_photo)&#10;                            .into(binding.profileCard.ivProfileAvatar)&#10;                    } else {&#10;                        binding.profileCard.ivProfileAvatar.setImageResource(R.drawable.ic_add_photo)&#10;                    }&#10;                } else {&#10;                    binding.profileCard.ivProfileAvatar.setImageResource(R.drawable.ic_add_photo)&#10;                }&#10;            }&#10;        }&#10;&#10;        db.collection(&quot;users&quot;).document(currentUser.uid).get()&#10;            .addOnSuccessListener { document -&gt;&#10;                if (document != null &amp;&amp; document.exists()) {&#10;                    lifecycleScope.launch(Dispatchers.IO) {&#10;                        val existingUser = userDao.getNonLiveUserById(currentUser.uid)&#10;&#10;                        val updatedUser = User(&#10;                            uid = currentUser.uid,&#10;                            email = currentUser.email,&#10;                            displayName = document.getString(&quot;displayName&quot;),&#10;                            school = document.getString(&quot;school&quot;),&#10;                            course = document.getString(&quot;course&quot;),&#10;                            yearLevel = document.getLong(&quot;yearLevel&quot;)?.toInt(),&#10;                            localProfilePictureUri = existingUser?.localProfilePictureUri&#10;                        )&#10;                        userDao.insertOrUpdateUser(updatedUser)&#10;                    }&#10;                } else {&#10;                    Log.d(&quot;HomeFragment&quot;, &quot;No Firestore document for user: ${currentUser.uid}&quot;)&#10;                }&#10;            }&#10;            .addOnFailureListener { exception -&gt;&#10;                Log.w(&quot;HomeFragment&quot;, &quot;Error getting documents: &quot;, exception)&#10;            }&#10;    }&#10;&#10;    private fun setDate() {&#10;        val monthDayFormat = SimpleDateFormat(&quot;MMMM d&quot;, Locale.getDefault())&#10;        val date = Date()&#10;        val day = SimpleDateFormat(&quot;d&quot;, Locale.getDefault()).format(date).toInt()&#10;&#10;        val daySuffix = getDayOfMonthSuffix(day)&#10;&#10;        val formattedDate = &quot;${monthDayFormat.format(date)}${daySuffix}&quot;&#10;&#10;        binding.tvDate.text = formattedDate&#10;    }&#10;&#10;    private fun getDayOfMonthSuffix(n: Int): String {&#10;        if (n in 11..13) {&#10;            return &quot;th&quot;&#10;        }&#10;        return when (n % 10) {&#10;            1 -&gt; &quot;st&quot;&#10;            2 -&gt; &quot;nd&quot;&#10;            3 -&gt; &quot;rd&quot;&#10;            else -&gt; &quot;th&quot;&#10;        }&#10;    }&#10;&#10;    private fun showLogoutDialog() {&#10;        AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;Logout&quot;)&#10;            .setMessage(&quot;Are you sure you want to log out?&quot;)&#10;            .setPositiveButton(&quot;Logout&quot;) { dialog, which -&gt;&#10;                logoutUser()&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;) { dialog, which -&gt;&#10;                dialog.dismiss()&#10;            }&#10;            .show()&#10;    }&#10;&#10;    private fun getPlaceholderTasks(): List&lt;Task&gt; {&#10;        return listOf(&#10;            Task(&#10;                id = &quot;1&quot;,&#10;                tasklistId = &quot;STCLOUD&quot;,&#10;                title = &quot;Finals Exam&quot;,&#10;                status = &quot;needsAction&quot;,&#10;                due = &quot;2025-06-28T09:00:00Z&quot;,&#10;                notes = &quot;Study all chapters for finals.&quot;,&#10;                updated = &quot;2025-06-20T10:00:00Z&quot;,&#10;                completed = null,&#10;                parent = null,&#10;                position = &quot;1&quot;,&#10;                isSynced = false,&#10;                isDeleted = false,&#10;                isCompleted = false,&#10;                dueDate = &quot;06/28/25&quot;,&#10;                dueTime = &quot;09:00AM&quot;,&#10;                //label = &quot;STCLOUD&quot;&#10;            ),&#10;            Task(&#10;                id = &quot;2&quot;,&#10;                tasklistId = &quot;MOBICOM&quot;,&#10;                title = &quot;MCO Presentation&quot;,&#10;                status = &quot;needsAction&quot;,&#10;                due = &quot;2025-06-30T14:00:00Z&quot;,&#10;                notes = &quot;Prepare slides for MCO.&quot;,&#10;                updated = &quot;2025-06-21T11:00:00Z&quot;,&#10;                completed = null,&#10;                parent = null,&#10;                position = &quot;2&quot;,&#10;                isSynced = false,&#10;                isDeleted = false,&#10;                isCompleted = false,&#10;                dueDate = &quot;06/30/25&quot;,&#10;                dueTime = &quot;02:00PM&quot;,&#10;                //label = &quot;MOBICOM&quot;&#10;            ),&#10;            Task(&#10;                id = &quot;3&quot;,&#10;                tasklistId = &quot;CSARCH2&quot;,&#10;                title = &quot;Review for Quiz 2&quot;,&#10;                status = &quot;needsAction&quot;,&#10;                due = &quot;2025-07-02T08:00:00Z&quot;,&#10;                notes = &quot;Focus on chapters 5-7.&quot;,&#10;                updated = &quot;2025-06-22T12:00:00Z&quot;,&#10;                completed = null,&#10;                parent = null,&#10;                position = &quot;3&quot;,&#10;                isSynced = false,&#10;                isDeleted = false,&#10;                isCompleted = false,&#10;                dueDate = &quot;07/02/25&quot;,&#10;                dueTime = &quot;08:00AM&quot;,&#10;                //label = &quot;CSARCH2&quot;&#10;            )&#10;        )&#10;    }&#10;&#10;    private fun showSettingsMenu(anchorView: View) {&#10;        val popup = PopupMenu(requireContext(), anchorView)&#10;        popup.menuInflater.inflate(R.menu.home_settings_menu, popup.menu)&#10;&#10;        popup.setOnMenuItemClickListener { menuItem -&gt;&#10;            when (menuItem.itemId) {&#10;                R.id.action_edit_profile -&gt; {&#10;                    val intent = Intent(requireActivity(), EditProfileActivity::class.java)&#10;                    startActivity(intent)&#10;                    true&#10;                }&#10;                R.id.action_logout -&gt; {&#10;                    showLogoutDialog()&#10;                    true&#10;                }&#10;                else -&gt; false&#10;            }&#10;        }&#10;        popup.show()&#10;    }&#10;&#10;    private fun logoutUser() {&#10;        auth.signOut()&#10;        // Intent to go back to the LandingActivity&#10;        val intent = Intent(requireActivity(), LandingActivity::class.java).apply {&#10;            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;        }&#10;        startActivity(intent)&#10;        requireActivity().finish() // Finish the MainActivity&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null // fragment lifecycle&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.mobicom.s17.group8.mobicom_mco.home&#10;&#10;import android.annotation.SuppressLint&#10;import android.app.AlertDialog&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import androidx.fragment.app.Fragment&#10;import android.util.Log&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.mobicom.s17.group8.mobicom_mco.R&#10;import com.mobicom.s17.group8.mobicom_mco.auth.LandingActivity&#10;import com.mobicom.s17.group8.mobicom_mco.databinding.FragmentHomeBinding&#10;import com.mobicom.s17.group8.mobicom_mco.databinding.ListItemTaskBinding&#10;import com.mobicom.s17.group8.mobicom_mco.database.tasks.Task&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;import com.google.firebase.auth.ktx.auth&#10;import com.google.firebase.ktx.Firebase&#10;import com.bumptech.glide.Glide&#10;import com.google.firebase.firestore.ktx.firestore&#10;import com.mobicom.s17.group8.mobicom_mco.database.AppDatabase&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import androidx.core.net.toUri&#10;import com.mobicom.s17.group8.mobicom_mco.database.user.User&#10;import com.mobicom.s17.group8.mobicom_mco.database.user.UserDao&#10;import android.widget.PopupMenu&#10;import com.bumptech.glide.signature.ObjectKey&#10;import java.io.File&#10;&#10;// --- local adapter since adding tasks are not yet implemented ---&#10;class HomeTaskAdapter(private val tasks: List&lt;Task&gt;) : RecyclerView.Adapter&lt;HomeTaskAdapter.TaskViewHolder&gt;() {&#10;&#10;    inner class TaskViewHolder(val binding: ListItemTaskBinding) : RecyclerView.ViewHolder(binding.root)&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TaskViewHolder {&#10;        val binding = ListItemTaskBinding.inflate(LayoutInflater.from(parent.context), parent, false)&#10;        return TaskViewHolder(binding)&#10;    }&#10;&#10;    @SuppressLint(&quot;SetTextI18n&quot;)&#10;    override fun onBindViewHolder(holder: TaskViewHolder, position: Int) {&#10;        val task = tasks[position]&#10;        holder.binding.apply {&#10;            taskNameTv.text = task.title&#10;            taskInfoTv.text = &quot;task label | ${task.dueDate}&quot; // &quot;${task.label} | ${task.dueDate}&quot;&#10;            taskCheckbox.isChecked = task.isCompleted&#10;            //starredIv.visibility = if (task.isStarred) View.VISIBLE else View.GONE&#10;        }&#10;    }&#10;&#10;    override fun getItemCount() = tasks.size&#10;}&#10;&#10;class HomeFragment : Fragment() {&#10;&#10;    private var _binding: FragmentHomeBinding? = null&#10;    private val binding get() = _binding!!&#10;    private val auth = Firebase.auth&#10;    private val db = Firebase.firestore&#10;    private lateinit var userDao: UserDao&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentHomeBinding.inflate(inflater, container, false)&#10;        userDao = AppDatabase.getDatabase(requireContext()).userDao()&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        loadAndObserveUserProfile()&#10;        setDate()&#10;&#10;        binding.ivSettings.setOnClickListener { view -&gt;&#10;            showSettingsMenu(view) // Pass the settings icon view itself&#10;        }&#10;&#10;//        binding.btnStartStudying.setOnClickListener {&#10;//            findNavController().navigate(R.id.nav_study)&#10;//        }&#10;&#10;        val tasksForToday = getPlaceholderTasks()&#10;        val homeTaskAdapter = HomeTaskAdapter(tasksForToday)&#10;        binding.rvHomeTasks.apply {&#10;            layoutManager = LinearLayoutManager(requireContext())&#10;            adapter = homeTaskAdapter&#10;        }&#10;    }&#10;&#10;    private fun loadAndObserveUserProfile() {&#10;        val currentUser = auth.currentUser&#10;        if (currentUser == null) {&#10;            logoutUser() // Should not happen, but safe to check&#10;            return&#10;        }&#10;&#10;        userDao.getUserById(currentUser.uid).observe(viewLifecycleOwner) { userEntity -&gt;&#10;            if (userEntity != null) {&#10;                binding.tvGreeting.text = getString(R.string.hello_user, userEntity.displayName ?: &quot;User&quot;)&#10;&#10;                binding.profileCard.apply {&#10;                    tvNameValue.text = userEntity.displayName ?: &quot;N/A&quot;&#10;                    tvSchoolValue.text = userEntity.school ?: &quot;N/A&quot;&#10;                    tvCourseValue.text = userEntity.course ?: &quot;N/A&quot;&#10;                    tvYearLevelValue.text = userEntity.yearLevel?.toString() ?: &quot;N/A&quot;&#10;                }&#10;&#10;                // Load the profile picture from the local URI&#10;                if (userEntity.localProfilePictureUri != null) {&#10;                    val imageUri = userEntity.localProfilePictureUri.toUri()&#10;                    val imageFile = imageUri.path?.let { File(it) }&#10;&#10;                    if (imageFile != null &amp;&amp; imageFile.exists()) {&#10;                        Glide.with(this@HomeFragment)&#10;                            .load(imageUri)&#10;                            .signature(ObjectKey(imageFile.lastModified()))&#10;                            .placeholder(R.drawable.ic_add_photo)&#10;                            .error(R.drawable.ic_add_photo)&#10;                            .into(binding.profileCard.ivProfileAvatar)&#10;                    } else {&#10;                        binding.profileCard.ivProfileAvatar.setImageResource(R.drawable.ic_add_photo)&#10;                    }&#10;                } else {&#10;                    binding.profileCard.ivProfileAvatar.setImageResource(R.drawable.ic_add_photo)&#10;                }&#10;            }&#10;        }&#10;&#10;        db.collection(&quot;users&quot;).document(currentUser.uid).get()&#10;            .addOnSuccessListener { document -&gt;&#10;                if (document != null &amp;&amp; document.exists()) {&#10;                    lifecycleScope.launch(Dispatchers.IO) {&#10;                        val existingUser = userDao.getNonLiveUserById(currentUser.uid)&#10;&#10;                        val updatedUser = User(&#10;                            uid = currentUser.uid,&#10;                            email = currentUser.email,&#10;                            displayName = document.getString(&quot;displayName&quot;),&#10;                            school = document.getString(&quot;school&quot;),&#10;                            course = document.getString(&quot;course&quot;),&#10;                            yearLevel = document.getLong(&quot;yearLevel&quot;)?.toInt(),&#10;                            localProfilePictureUri = existingUser?.localProfilePictureUri&#10;                        )&#10;                        userDao.insertOrUpdateUser(updatedUser)&#10;                    }&#10;                } else {&#10;                    Log.d(&quot;HomeFragment&quot;, &quot;No Firestore document for user: ${currentUser.uid}&quot;)&#10;                }&#10;            }&#10;            .addOnFailureListener { exception -&gt;&#10;                Log.w(&quot;HomeFragment&quot;, &quot;Error getting documents: &quot;, exception)&#10;            }&#10;    }&#10;&#10;    private fun setDate() {&#10;        val monthDayFormat = SimpleDateFormat(&quot;MMMM d&quot;, Locale.getDefault())&#10;        val date = Date()&#10;        val day = SimpleDateFormat(&quot;d&quot;, Locale.getDefault()).format(date).toInt()&#10;&#10;        val daySuffix = getDayOfMonthSuffix(day)&#10;&#10;        val formattedDate = &quot;${monthDayFormat.format(date)}${daySuffix}&quot;&#10;&#10;        binding.tvDate.text = formattedDate&#10;    }&#10;&#10;    private fun getDayOfMonthSuffix(n: Int): String {&#10;        if (n in 11..13) {&#10;            return &quot;th&quot;&#10;        }&#10;        return when (n % 10) {&#10;            1 -&gt; &quot;st&quot;&#10;            2 -&gt; &quot;nd&quot;&#10;            3 -&gt; &quot;rd&quot;&#10;            else -&gt; &quot;th&quot;&#10;        }&#10;    }&#10;&#10;    private fun showLogoutDialog() {&#10;        AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;Logout&quot;)&#10;            .setMessage(&quot;Are you sure you want to log out?&quot;)&#10;            .setPositiveButton(&quot;Logout&quot;) { dialog, which -&gt;&#10;                logoutUser()&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;) { dialog, which -&gt;&#10;                dialog.dismiss()&#10;            }&#10;            .show()&#10;    }&#10;&#10;    private fun getPlaceholderTasks(): List&lt;Task&gt; {&#10;        return listOf(&#10;            Task(&#10;                id = &quot;1&quot;,&#10;                userId = &quot;user1&quot;,&#10;                tasklistId = &quot;STCLOUD&quot;,&#10;                title = &quot;Finals Exam&quot;,&#10;                status = &quot;needsAction&quot;,&#10;                due = &quot;2025-06-28T09:00:00Z&quot;,&#10;                notes = &quot;Study all chapters for finals.&quot;,&#10;                updated = &quot;2025-06-20T10:00:00Z&quot;,&#10;                completed = null,&#10;                parent = null,&#10;                position = &quot;1&quot;,&#10;                isSynced = false,&#10;                isDeleted = false,&#10;                isCompleted = false,&#10;                dueDate = &quot;06/28/25&quot;,&#10;                dueTime = &quot;09:00AM&quot;&#10;            ),&#10;            Task(&#10;                id = &quot;2&quot;,&#10;                userId = &quot;user1&quot;,&#10;                tasklistId = &quot;MOBICOM&quot;,&#10;                title = &quot;MCO Presentation&quot;,&#10;                status = &quot;needsAction&quot;,&#10;                due = &quot;2025-06-30T14:00:00Z&quot;,&#10;                notes = &quot;Prepare slides for MCO.&quot;,&#10;                updated = &quot;2025-06-21T11:00:00Z&quot;,&#10;                completed = null,&#10;                parent = null,&#10;                position = &quot;2&quot;,&#10;                isSynced = false,&#10;                isDeleted = false,&#10;                isCompleted = false,&#10;                dueDate = &quot;06/30/25&quot;,&#10;                dueTime = &quot;02:00PM&quot;&#10;            ),&#10;            Task(&#10;                id = &quot;3&quot;,&#10;                userId = &quot;user1&quot;,&#10;                tasklistId = &quot;CSARCH2&quot;,&#10;                title = &quot;Review for Quiz 2&quot;,&#10;                status = &quot;needsAction&quot;,&#10;                due = &quot;2025-07-02T08:00:00Z&quot;,&#10;                notes = &quot;Focus on chapters 5-7.&quot;,&#10;                updated = &quot;2025-06-22T12:00:00Z&quot;,&#10;                completed = null,&#10;                parent = null,&#10;                position = &quot;3&quot;,&#10;                isSynced = false,&#10;                isDeleted = false,&#10;                isCompleted = false,&#10;                dueDate = &quot;07/02/25&quot;,&#10;                dueTime = &quot;08:00AM&quot;&#10;            )&#10;        )&#10;    }&#10;&#10;    private fun showSettingsMenu(anchorView: View) {&#10;        val popup = PopupMenu(requireContext(), anchorView)&#10;        popup.menuInflater.inflate(R.menu.home_settings_menu, popup.menu)&#10;&#10;        popup.setOnMenuItemClickListener { menuItem -&gt;&#10;            when (menuItem.itemId) {&#10;                R.id.action_edit_profile -&gt; {&#10;                    val intent = Intent(requireActivity(), EditProfileActivity::class.java)&#10;                    startActivity(intent)&#10;                    true&#10;                }&#10;                R.id.action_logout -&gt; {&#10;                    showLogoutDialog()&#10;                    true&#10;                }&#10;                else -&gt; false&#10;            }&#10;        }&#10;        popup.show()&#10;    }&#10;&#10;    private fun logoutUser() {&#10;        auth.signOut()&#10;        // Intent to go back to the LandingActivity&#10;        val intent = Intent(requireActivity(), LandingActivity::class.java).apply {&#10;            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;        }&#10;        startActivity(intent)&#10;        requireActivity().finish() // Finish the MainActivity&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null // fragment lifecycle&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>